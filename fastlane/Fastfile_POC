# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

default_platform(:ios)

platform :ios do
desc <<~DOC
  Generate certificates and provisioning profiles for app development.
  
  This lane creates new development certificates and provisioning profiles from scratch.
  Use this when setting up code signing for the first time or when certificates have expired.
  
  Parameters:
    distribution_type - Type of distribution: "development", "adhoc", "appstore" (default: "development")
  
  Environment Variables:
    APP_IDENTIFIER    - Bundle identifier for the app (e.g. com.company.app)
    MATCH_GIT_URL     - Git URL with authentication token for the match certificates repository
                        Format: https://<token>@github.com/organization/repo.git
DOC
lane :generate_certificates do
    match(
      app_identifier: ["net.gini.healthsdk.example"],
      type: "development",
      generate_apple_certs: true,
      force_for_new_devices: true
    )
end

desc <<~DOC
  Refresh provisioning profiles without generating new certificates.
  
  This lane updates existing provisioning profiles to include new devices or 
  refresh expired profiles while keeping the existing certificates intact.
  Use this when you need to add new devices or refresh profiles without creating new certificates.
  
  Parameters:
    distribution_type - Type of distribution: "development", "adhoc", "appstore" (default: "development")
  
  Environment Variables:
    APP_IDENTIFIER    - Bundle identifier for the app (e.g. com.company.app)
    MATCH_GIT_URL     - Git URL with authentication token for the match certificates repository
                        Format: https://<token>@github.com/organization/repo.git
DOC
lane :refresh_profiles do
    match(
      app_identifier: ["net.gini.healthsdk.example"],
      type: "development",
      generate_apple_certs: false,
      force_for_new_devices: true
    )
end

desc <<~DOC
  Register new devices from a devices file.
  
  This lane reads device UDIDs and names from a text file and registers them
  with your Apple Developer account. The devices file should contain one device
  per line in the format: "UDID<tab>Device Name" or just "UDID".
  
  Parameters:
    devices_file - Path to the devices file (default: "./devices.txt")
  
  Example devices.txt format:
    1234567890abcdef1234567890abcdef12345678	John's iPhone
    abcdef1234567890abcdef1234567890123456	Jane's iPad
DOC
lane :register_new_devices do 
    register_devices(devices_file: "./devices.txt")
end

# desc <<~DOC
#   Register new devices by passing device information directly.
  
#   This lane registers devices with your Apple Developer account by passing
#   device UDIDs and names directly as parameters, without needing a file.
  
#   Parameters:
#     devices - Hash of devices in format: {"UDID" => "Device Name", ...}
  
#   Example usage:
#     fastlane register_devices_direct devices:'{"1234567890abcdef":"John iPhone","abcdef1234567890":"Jane iPad"}'
# DOC
# lane :register_devices_direct do |options|
#   devices = options[:devices] || {}
  
#   if devices.empty?
#     UI.error("No devices provided. Please pass devices as: devices:'{\"UDID\":\"Name\"}'")
#     next
#   end
  
#   register_devices(devices: devices)
# end
  
desc <<~DOC
Runs unit tests for a given target using the `scan` action (a wrapper around xcodebuild).

Parameters:
- `target`: The name of the target whose test scheme will be executed. Example: `GinBankSDK`.
- `destination`: The destination for the tests. Example: `platform=iOS Simulator,name=iPhone 15,OS=17.4`.
- `clientSecret`: The clientSecret for the hosting app
DOC

lane :run_unit_tests do |options|
  target = options[:target]
  destination = options[:destination]
  clientSecret = options[:clientSecret]

  unless target && destination
    UI.user_error!("Missing 'target' or 'destination' parameter. Pass both to run the tests.")
  end

  scan(
    workspace: "GiniMobile.xcworkspace",
    scheme: target,
    clean: true,
    destination: destination,
    disable_concurrent_testing: false,
    xcargs: [
      'CLIENT_ID="gini-mobile-test"',
      "CLIENT_SECRET=#{clientSecret}",
      'CODE_SIGNING_REQUIRED=NO',
      'CODE_SIGN_IDENTITY=""',
      'ONLY_ACTIVE_ARCH=NO'
    ].join(' '),
    output_types: "",                 # prevent report generation
    output_directory: "./tmp_test_output",
    fail_build: true,
    code_coverage: true
  )
  
  # Clean up the report files that were generated
  sh("rm -rf ./tmp_test_output") if File.exist?("./tmp_test_output")
  sh("rm -rf ./tmp_derived_data") if File.exist?("./tmp_derived_data")
end


  desc <<~DOC
  Set up provisioning profiles for app distribution.
  
  This lane handles code signing setup by downloading and installing the necessary
  provisioning profiles from the match repository.
  
  Parameters:
    distribution_type - Type of distribution: "adhoc" or "development" (default: "adhoc")
  
  Environment Variables:
    APP_IDENTIFIER    - Bundle identifier for the app (e.g. com.company.app)
    MATCH_GIT_URL     - Git URL with authentication token for the match certificates repository
                        Format: https://<token>@github.com/organization/repo.git
DOC
lane :setup_provisioning do |options|
  bundle_id = ENV["APP_IDENTIFIER"]
  distribution_type = options[:distribution_type]
  
  match(
    type: distribution_type,
    app_identifier: [bundle_id],
    git_url: ENV["MATCH_GIT_URL"],
    keychain_name: "app-signing",
    keychain_password:ENV['KEYCHAIN_PASSWORD'],
    readonly: true
  )
end

desc <<~DOC
  Build and export app as an IPA.
  
  This lane compiles the specified app scheme, archives it, and exports it as an IPA file 
  ready for distribution. The build includes cleaning and detailed logging for debugging.
  
  Parameters:
    export_method - Export method: "ad-hoc" or "development" (default: "ad-hoc")
    configuration - The configuration from the Xcode project setup: "Release", "Debug"
  
  Environment Variables:
    APP_SCHEME    - Xcode scheme to build
    IPA_FILE      - Output name for the generated IPA file (without extension)
DOC
lane :build_app_match do |options|
  scheme = ENV["APP_SCHEME"]
  ipaFile = ENV["IPA_FILE"]
  export_method = options[:export_method]
  configuration = options[:configuration]

  # Skip confirmation for development builds in CI
  if export_method == "development"
    ENV["FASTLANE_SKIP_WAITING_FOR_BUILD_PROCESSING"] = "true"
    puts "⚠️  Skipping waiting for build processing (development build)"
  end
  gym(
    scheme: scheme,
    export_method: export_method,
    configuration: configuration,
    silent: false,
    clean: true,
    export_options: { 
      manageAppVersionAndBuildNumber: false 
    },
    export_team_id: "JA825X8F7Z",
    output_name: ipaFile
  )
end

desc <<~DOC
  Create a temporary keychain for CI builds and expose its credentials to the environment.

  Parameters:
    keychain_name       - Name of the keychain to create.
    keychain_password   - Password for the keychain.
    default_keychain    - Whether to set the keychain as the default.
    timeout             -Auto-lock timeout in seconds. Default: 3600 (1 hour).

  Behavior:
    - Creates and unlocks the keychain.
    - Exposes keychain_name and keychain_password for reuse in other lanes (e.g., match/gym).
DOC
lane :setup_temp_keychain do
  keychain_name = "app-signing"
  keychain_password = ENV["KEYCHAIN_PASSWORD"]

  create_keychain(
    name: keychain_name,
    password: keychain_password,
    default_keychain: true,
    unlock: true,
    timeout: 21600,
    lock_when_sleeps: false,
    add_to_search_list: true
  )
end

desc <<~DOC
  Unlock the signing keychain and set it as the default so codesign can access identities.

  Parameters:
    path            - Keychain name or full path. Example: "app-signing" or "app-signing.keychain-db".
    password        - Password used to unlock the keychain.
    set_default     - Whether to make the unlocked keychain the default for this session. Here: true.

  Behavior:
    - Unlocks the keychain at `path` with the provided password.
    - Sets it as the default keychain (because set_default: true), which is often required in CI.

  Environment:
    - KEYCHAIN_PASSWORD must be set to the keychain’s password.
DOC
lane :unlock_temp_keychain do
  unlock_keychain(
      path: "app-signing",
      password: ENV['KEYCHAIN_PASSWORD'],
      set_default: true
  )
end

desc "Delete temp signing keychain"
lane :delete_temp_keychain do
  delete_keychain(name: "app-signing")
end


desc <<~DOC
  Complete build process for app distribution.
  
  This lane combines provisioning setup and app building into a single workflow.
  It first sets up the necessary code signing certificates and provisioning profiles,
  then builds and exports the app as an IPA ready for distribution.
  
  Parameters:
    distribution_type - Type of distribution for provisioning: "adhoc" or "development" (default: "adhoc")
    export_method     - Export method for build: "ad-hoc" or "development" (default: "ad-hoc")
    configuration     - The configuration from the Xcode project setup: "Release", "Debug"
  
  Environment Variables:
    APP_IDENTIFIER    - Bundle identifier for the app
    APP_SCHEME        - Xcode scheme to build
    IPA_FILE          - Output name for the generated IPA file (without extension)
    MATCH_GIT_URL     - Git URL for the match certificates repository
DOC
lane :build_app_with_provisioning do |options|
  distribution_type = options[:distribution_type]
  export_method = options[:export_method]
  configuration = options[:configuration]
  
  setup_temp_keychain
  unlock_temp_keychain
  setup_provisioning(distribution_type: distribution_type)
  build_app_match(export_method: export_method, configuration: configuration)
ensure
  # Always clean up
  delete_temp_keychain
end

# Convenience lanes for specific distribution types
desc "Build app for ad-hoc distribution"
lane :build_app_adhoc do
  build_app_with_provisioning(distribution_type: "adhoc", export_method: "ad-hoc", configuration: "Release")
end

desc "Build app for development distribution"
lane :build_app_development do
  build_app_with_provisioning(distribution_type: "development", export_method: "development", configuration: "Debug")
end

desc "Distribute the app to Firebase App Distribution"
  lane :distribute_to_firebase do
    # Verify required environment variables
    required_vars = ['FIREBASE_APP_ID', 'FIREBASE_SERVICE_ACCOUNT_JSON', 'IPA_FILE', 'DISTRIBUTION_GROUPS']
    required_vars.each do |var|
      if ENV[var].nil? || ENV[var].empty?
        UI.user_error!("Required environment variable '#{var}' is not defined")
      end
    end
    
    # Create temporary file for service account
    require 'tempfile'
    service_account_file = Tempfile.new(['firebase-service-account', '.json'])
    
    begin
      # Write service account credentials to temporary file
      File.write(service_account_file.path, ENV['FIREBASE_SERVICE_ACCOUNT_JSON'])
      
      # Handle IPA file path - look in parent directory where artifact was downloaded
      ipa_filename = ENV['IPA_FILE']
      
      # Add .ipa extension if not present
      unless ipa_filename.end_with?('.ipa')
        ipa_filename = "#{ipa_filename}.ipa"
      end
      
      # Get absolute path to parent directory (project root)
      parent_dir = File.expand_path('..')
      
      # Look for IPA file in parent directory using absolute path
      ipa_path = nil
      absolute_ipa_path = File.join(parent_dir, ipa_filename)
      
      if File.exist?(absolute_ipa_path)
        ipa_path = absolute_ipa_path
      else
        # If exact filename not found, use any IPA file in parent directory with absolute path
        ipa_files_parent = Dir.glob("../*.ipa")
        if ipa_files_parent.any?
          relative_ipa_path = ipa_files_parent.first
          ipa_path = File.expand_path(relative_ipa_path)
        else
          UI.user_error!("No IPA files found in parent directory. Expected: #{absolute_ipa_path}")
        end
      end
      
      # Use official Firebase App Distribution plugin
      firebase_app_distribution(
        app: ENV['FIREBASE_APP_ID'],
        ipa_path: ipa_path,
        groups: ENV['DISTRIBUTION_GROUPS'],
        release_notes: ENV['RELEASE_NOTES'] || "Automatic distribution from CI/CD",
        service_credentials_file: service_account_file.path
      )
      
    rescue => e
      UI.error("Error during distribution: #{e.message}")
      raise e
    ensure
      # Clean up temporary file
      if service_account_file
        service_account_file.close
        service_account_file.unlink
      end
    end
  end
end
