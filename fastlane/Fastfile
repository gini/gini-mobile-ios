# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

default_platform(:ios)

load "util/lanes.rb"
load "util/versions.rb"
load "util/git.rb" 
load "util/swift_package_releases.rb"

platform :ios do
  desc <<~DOC
    Publish a swift package to our release repository.
    
    Parameters:
      project_folder        - the folder of the project to be released (e.g., HealthAPILibrary, HealthSDK)"
      package_folder        - the folder to the swift package to be released (e.g., GiniHealthAPILibrary, GiniHealthAPILibraryPinning)"
      version_file_path     - the path to the file containing the package version
      git_tag               - the git tag name used to release the project
      repo_url              - the url of the release repository
      repo_user             - the username to use for authentication
      repo_password         - the password to use for authentication
      ci                    - set to "true" if running on a CI machine

  DOC
  lane :publish_swift_package do |options|
    (project_folder, package_folder, version_file_path, git_tag, repo_url, repo_user, repo_password, ci) = 
      check_and_get_options(options, [:project_folder, :package_folder, :version_file_path, :git_tag, :repo_url, :repo_user, :repo_password, :ci], UI)

      tag_version = get_project_version_from_tag(package_folder, git_tag, UI)
      package_version = get_project_version_from_version_file(version_file_path, UI)

      if tag_version != package_version
        UI.abort_with_message!  <<~MESSAGE
          Version in the tag is different from the package version:
            * tag       : #{tag_version}
            * project   : #{package_version}
          
          Change the version in the tag or update the packages's version in "#{version_file_path}".
        MESSAGE
      end

      UI.message <<~MESSAGE
        Will release to the release repository:
          * repository url  : #{repo_url}
          * project:        : #{project_folder}
          * swift package   : #{package_folder}
          * version         : #{package_version}
      MESSAGE

      if ci
        configure_git_on_ci_machines("Team Mobile Schorsch", "team-mobile@gini.net")
      end

      release_repo_path = checkout_release_repo(repo_url, repo_user, repo_password)

      copy_swift_package_to_release_repo(release_repo_path, project_folder, package_folder)

      update_release_repo(release_repo_path, package_version)
      
      UI.success <<~MESSAGE
        Successfully released to the release repository:
          * repository url  : #{repo_url}
          * project:        : #{project_folder}
          * swift package   : #{package_folder}
          * version         : #{package_version}
      MESSAGE

  end

  desc <<~DOC
  Build a documentation.
   
  Parameters:
    project_folder        - the folder of the project to be released (e.g., HealthAPILibrary, HealthSDK)
    package_folder        - the folder to the swift package to be released (e.g., GiniHealthAPILibrary, GiniHealthAPILibraryPinning)
  DOC
  lane :build_docs do |options|
    (project_folder, package_folder) = 
      check_and_get_options(options, [:project_folder, :package_folder], UI)
      
    jazzy config: "#{project_folder}/#{package_folder}/.jazzy.yaml"

    UI.success <<~MESSAGE
      Documentation successfully built:
        * available at    : #{project_folder}/#{package_folder}/Documentation/Api
    MESSAGE

  end

  desc <<~DOC
    Publish a documentation to gh-pages.
    
    Parameters:
      project_folder        - the folder of the project to be released (e.g., HealthAPILibrary, HealthSDK)
      package_folder        - the folder to the swift package to be released (e.g., GiniHealthAPILibrary, GiniHealthAPILibraryPinning)
      version_file_path     - the path to the file containing the package version
      git_tag               - the git tag name used to release the project
      repo_user             - the username to use for authentication
      repo_password         - the password to use for authentication
      ci                    - set to "true" if running on a CI machine

  DOC
  lane :publish_docs do |options|
    (project_folder, package_folder, version_file_path, git_tag, repo_user, repo_password, ci) = 
      check_and_get_options(options, [:project_folder, :package_folder, :version_file_path, :git_tag, :repo_user, :repo_password, :ci], UI)

      build_docs(project_folder: project_folder, package_folder: package_folder)

      tag_version = get_project_version_from_tag(package_folder, git_tag, UI)
      package_version = get_project_version_from_version_file(version_file_path, UI)

      if tag_version != package_version
        UI.abort_with_message!  <<~MESSAGE
          Version in the tag is different from the project version:
            * tag       : #{tag_version}
            * project   : #{package_version}
          
          Change the version in the tag or update the project's version in "#{version_file_path}"
        MESSAGE
      end

      UI.message <<~MESSAGE
      Start docs release:
        * project_folder      : #{project_folder}
        * package_folder      : #{package_folder}
        * git tag             : #{git_tag}
        * destination branch  : gh-pages
        * destination folder  : #{package_folder}/
        * url                 : "https://developer.gini.net/gini-mobile-ios/#{package_folder}/index.html"
     MESSAGE

      if ci
        configure_git_on_ci_machines("Team Mobile Schorsch", "team-mobile@gini.net")
      end

      # Clear gh-pages directory 
      sh("rm -rf gh-pages")

      # Clone
      sh("git clone -b gh-pages https://#{repo_user}:#{repo_password}@github.com/gini/gini-mobile-ios.git gh-pages")

      Dir.chdir("gh-pages") do
        UI.message "Clear out the existing documentation"
        sh("git rm -rf #{package_folder} --ignore-unmatch && git clean -fd")

        UI.message "Copy over the current documentation"
        sh("cp -R ../../#{project_folder}/#{package_folder}/Documentation/Api/ #{package_folder}")

        UI.message "Disable jekyll"
        sh("touch .nojekyll")

        UI.message "Commit and push the new documentation"
        sh("git add --all")
        sh("git diff --quiet --exit-code --cached || git commit -m 'Release #{package_folder} documentation for tag #{git_tag}' --author='Team Mobile <team-mobile@gini.net>'")
        sh("git push origin gh-pages")
      end

      UI.success <<~MESSAGE
      Documentation released:
        * project_folder      : #{project_folder}
        * package_folder      : #{package_folder}
        * git_tag             : #{git_tag}
        * destination branch  : gh-pages
        * destination folder  : #{package_folder}/
        * url                 : https://developer.gini.net/gini-mobile-ios/#{package_folder}/index.html
      MESSAGE
  end

  desc <<~DOC
    Create release tags for all packages that have different versions than their latest release tag.
  DOC
  lane :create_release_tags do |options|

    # Not all packages require own release tags (some are released automatically with other packages)
    ignored_packages = [/\/.+Pinning\//]

    Dir.chdir("..") do
      # Gather all packages which have a (...)Version.swift file
      packages = Dir["./**/*Version.swift"]
        .map { |version_file|
          if ignored_packages.find { |ignored| version_file =~ ignored }
            next nil
          end

          contents = File.open(version_file).read

          if match = contents.match(/=.*?"(.+)"/)
            components = version_file.split("/")
            { :package_folder => components[2], :version => match.captures[0] }
          end
        }
        .compact

      up_to_date = []
      to_be_released = []

      # Create release tags for packages which have different versions than their latest release tag
      packages.each do |package|
        if package[:version] == get_latest_version_from_release_tags(package[:package_folder], UI)
          up_to_date.push package
        else
          to_be_released.push package
          git_create_release_tag(package[:package_folder], package[:version])

          if UI.confirm("Push release tag?")
            git_push_release_tag(package[:package_folder], package[:version])
          end
        end
      end

      if to_be_released.empty?
        UI.success "All packages are up-to-date. No release tags needed."
      else
        UI.message <<~MESSAGE
            Following packages are up-to-date:
              #{up_to_date.map{ |package| "- #{package[:package_folder]} #{package[:version]}" }.join("\n  ") }
          MESSAGE

        UI.success <<~MESSAGE
            Created release tags for:
              #{to_be_released.map{ |package| "- #{package[:package_folder]} #{package[:version]}" }.join("\n  ") }
          MESSAGE
      end
    end
  end
  
  desc <<~DOC
    Create documentation release tags for all packages that have documentation that changed since their latest release.
  DOC
  lane :create_documentation_release_tags do
    Dir.chdir("..") do
      new_doc_release_tags = Dir["./**/Documentation"]
        .filter { |doc_dir|
          # Gather all projects which have documentation that changed since the last release
          components = doc_dir.split("/")
          puts components
          package_folder = components[2]
          puts package_folder
          did_folder_change_since_last_release(package_folder, doc_dir, UI)
        }
        .map { |doc_dir|
          # Create documentation release tags
          components = doc_dir.split("/")
          package_folder = components[2]
          latest_release_tag = get_latest_release_tag(package_folder)

          if match = latest_release_tag.match(/(^.*?;)doc.*?([0-9]+)/)
            next_doc_release_nr = match.captures[1].to_i + 1
            "#{match.captures[0]}doc-#{next_doc_release_nr}"
          else
            "#{latest_release_tag};doc-1"
          end
        }

      puts new_doc_release_tags
      
      if new_doc_release_tags.empty?
        UI.success "Every documentation is up-to-date. No documentation release tags needed."
      else
        # Create and push tags
        new_doc_release_tags.each do |new_doc_release_tag|
          git_create_tag(new_doc_release_tag)

          if UI.confirm("Push documentation release tag?")
            git_push_tag(new_doc_release_tag)
          end
        end
        
        UI.success <<~MESSAGE
            Created documentation release tags for:
              #{new_doc_release_tags.map{ |tag| "- #{tag}" }.join("\n  ") }
          MESSAGE
      end
    end
  end

  desc <<~DOC
    Setup Manual Signing for project at path
  DOC
  lane :setup_manual_signing do |options|
    (project_path, team_id, bundle_identifier, profile_name, entitlements_file_path, ci) = 
      check_and_get_options(options, [:project_path, :team_id, :bundle_identifier, :profile_name, :entitlements_file_path, :ci], UI)

    update_code_signing_settings(
      use_automatic_signing: false,
      path: project_path,
      team_id: team_id,
      bundle_identifier: bundle_identifier,
      profile_name: profile_name,
      entitlements_file_path: entitlements_file_path
    )
  end
  
end
